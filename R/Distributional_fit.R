#' Get distributional similarity to a reference dataset.
#'
#' @param Sample Sample data to compare to a reference data set. It has to have
#' a factor/character variable defining the distributional blocks to evaluate.
#' @param Reference.Data Reference data to compare the sample data to. It needs
#' to have a block variable with the same name as in the sample data.
#' @param var Name of the block variable, which need to be present in both the
#' sample and the reference data.
#' @param method Which method to use to evaluate the distributional fit of the
#' sample in relation to the reference data.
#'
#' @import dplyr
#' @import arm
#'
#' @return A numeneric score. Higher values indicate better distributional
#' similarity between sample and reference data.
#' @export
#'
#' @examples
#'
#' ## Get distributional similarity between the initial sample and the reference
#' ## data in terms of regional distribution
#'
#' get.distr.fit(Sample.Data, Reference.Data, var = 'Region')
#'
#' ## Check the fit a sub-sample generated by the Probability procedure
#' quantiles <- quantile(Reference.Data$Beds, seq(0, 1, length.out = 10)) %>%
#'     round()
#'
#' Reference.Data$Block <- with(Reference.Data, Hmisc::cut2(Beds, quantiles) %>%
#'     paste('-', Region))
#' Sample.Data$Block <- with(Sample.Data, Hmisc::cut2(Beds, quantiles) %>%
#'     paste('-', Region))
#'
#' results <- probability.sampling(Sample.Data, Reference.Data, n.required = 56)
#'
#' get.distr.fit(results, Reference.Data)
#'

get.distr.fit <- function(Sample, Reference, var = 'Block', method = c('logLik', 'spearman')) {

	library(dplyr)
	library(arm)

	if (!(var %in% colnames(Sample) & var %in% colnames(Reference))) stop(paste(var, 'must be in both sample and reference data'))

	method <- match.arg(method)

	# Normalize the name of the block variable in both datasets
	Reference$Block <- Reference[[var]]
	Sample$Block <- Sample[[var]]

	# Generate a common list of possible blocks between datasets
	lvls <- c(Reference$Block, Sample$Block) %>% unique()
	Reference$Block <- factor(Reference$Block, levels = lvls)
	Sample$Block <- factor(Sample$Block, levels = lvls)

	if (method == 'logLik') { # Likelihood method

		# Compute block frequencies in the reference data
		Blocks <- count(Reference, Block, name = 'Freq', .drop = F) %>% mutate(Tot = sum(Freq))

		# Create a model of block representativeness starting from the reference.
		# The model is a regularized logistic regression which gives a bit of
		# probability also to rare blocks, since zeroes would create computational
		# problems later on.
		model <- arm::bayesglm(cbind(Freq, Tot - Freq) ~ Block, quasibinomial(), Blocks)

		# Assign the data likelihood (probability of observing a hospital from a
		# certain block, given its probability at the country level)
		Sample <- Sample %>% mutate(P = predict(model, newdata = data.frame(Block)) %>% invlogit())

		# Create the final score by summing up the log of the hospitals' likelihood
		Sample$P %>% log %>% sum
	}
	else if (method == 'spearman') {  # Correlation method
		# Compute frequencies for both sample and reference data
		freq.sample <- as.vector(table(Sample$Block) / nrow(Sample))
		freq.reference <- as.vector(table(Reference$Block) / nrow(Reference))

		# Estimate the correlation between these two frequencies
		cor(freq.sample, freq.reference, method = 'spearman')
	}

	##TODO: add a divergence measure estimated on the Reference Data, like KL divergence
}